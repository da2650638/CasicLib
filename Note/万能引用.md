在 C++11 中，也许最重要的新特性就是右值引用（rvalue references）；它们是实现移动语义（move semantics）和完美转发（perfect forwarding）的基础。（如果你不熟悉右值引用、移动语义或完美转发的基础知识，建议先阅读 Thomas Becker 的概述文章，然后再继续。）

从语法上看，右值引用的声明方式类似于“普通”引用（现在被称为左值引用），唯一的区别是你需要使用两个 `&` 而不是一个。例如，这个函数接受一个类型为右值引用 `Widget&&` 的参数：

```cpp
void f(Widget&& param);
```

既然右值引用是用 `&&` 声明的，似乎合理地认为，只要在类型声明中看到 `&&`，就意味着右值引用。然而，事实并非如此：

```cpp
Widget&& var1 = someWidget;      // 这里，"&&" 表示右值引用
 
auto&& var2 = var1;              // 这里，"&&" 并不表示右值引用
 
template<typename T>
void f(std::vector<T>&& param);  // 这里，"&&" 表示右值引用
 
template<typename T>
void f(T&& param);               // 这里，"&&" 并不表示右值引用
```

在本文中，我将描述在类型声明中 `&&` 的两种含义，解释如何区分它们，并引入新的术语，使我们能够清楚地表达 `&&` 的具体含义。区分这些不同的含义非常重要，因为如果你在看到类型声明中的 `&&` 时就认为它表示“右值引用”，你将误解很多 C++11 代码。

问题的关键在于，类型声明中的 `&&` 有时表示右值引用，但有时表示的是**右值引用或左值引用**。因此，某些出现在源码中的 `&&` 实际上可能意味着 `&`。换句话说，它们在语法上看起来像右值引用（即“&&”），但语义上却表示左值引用（即“&”）。这种特殊的引用比左值引用或右值引用更加灵活。例如，右值引用只能绑定到右值，而左值引用不仅可以绑定到左值，在有限的条件下也可以绑定到右值。而用 `&&` 声明的、可能是左值引用或右值引用的这种引用可以绑定到任何值。这样的引用极为灵活，值得拥有自己的名称。我称它们为**万能引用（universal references）**。

何时 `&&` 表示万能引用（即源码中的 `&&` 实际上意味着 `&`）的具体细节比较复杂，因此我会推迟详细讨论这些细节。目前，让我们先记住一个日常编程中需要用到的经验法则：

> 如果变量或参数被声明为 `T&&`，且 `T` 是某个推导出来的类型，那么该变量或参数是万能引用。

需要类型推导参与的这一条件限制了万能引用出现的场景。实际上，几乎所有的万能引用都是函数模板的参数。而由于 `auto` 声明的变量类型推导规则与模板类型推导基本一致，因此 `auto` 声明的变量也可以是万能引用。这种情况在实际生产代码中很少见，但我会在本文中展示一些例子，因为它们比模板例子更简洁。在本文稍后的细节部分，我会解释，在结合 `typedef` 和 `decltype` 的使用时，也可能出现万能引用，但在我们深入细节之前，请暂且认为万能引用仅与函数模板参数和 `auto` 声明的变量相关。

万能引用的形式必须是 `T&&`，这比表面上看起来更重要，但我会稍后再深入讨论这一点。现在，请先简单记住这个条件。

和所有引用一样，万能引用必须被初始化，并且引用的初始化表达式决定了它是左值引用还是右值引用：
- 如果用来初始化万能引用的表达式是左值，则万能引用变为左值引用。
- 如果用来初始化万能引用的表达式是右值，则万能引用变为右值引用。

这些信息的价值在于，你能够区分左值和右值。精确定义这两个术语是很困难的（C++11 标准通常基于具体情况逐个定义表达式是左值还是右值），但在实践中，以下定义通常足够：
- 如果你可以对一个表达式取地址，则该表达式是左值。
- 如果一个表达式的类型是左值引用（例如 `T&` 或 `const T&` 等），则该表达式是左值。
- 否则，该表达式是右值。从概念上讲（并且通常也是事实），右值对应于临时对象，比如从函数返回的对象或通过隐式类型转换创建的对象。大多数字面值（如 `10` 和 `5.3`）也是右值。

让我们再次来看本文开头的这段代码：

```cpp
Widget&& var1 = someWidget;
auto&& var2 = var1;
```

你可以对 `var1` 取地址，因此 `var1` 是一个左值。`var2` 的类型声明是 `auto&&`，这使它成为一个**万能引用**。由于它被 `var1`（一个左值）初始化，`var2` 变成了一个左值引用。从代码表面上看，你可能会认为 `var2` 是一个右值引用；它的声明中的 “&&” 确实会让人得出这样的结论。然而，由于它是一个万能引用，并且被左值初始化，`var2` 变成了一个左值引用。其效果就像这样：

```cpp
Widget& var2 = var1;
```

如上所述，如果一个表达式的类型是左值引用，那么它就是一个左值。再来看下面的例子：

```cpp
std::vector<int> v;
...
auto&& val = v[0];               // val 成为一个左值引用（详见下文）
```

`val` 是一个万能引用，并且它被 `v[0]` 初始化。`v[0]` 是对 `std::vector<int>::operator[]` 的调用结果。该函数返回一个对向量元素的左值引用。[2] 由于所有的左值引用都是左值，并且由于这个左值被用来初始化 `val`，因此 `val` 成为了一个左值引用，即使它看起来像是右值引用的声明。

我之前提到，万能引用最常见于模板函数的参数。再来看本文开头的这个模板：

```cpp
template<typename T>
void f(T&& param);               // “&&” 可能表示右值引用
```

假设我们这样调用 `f`：

```cpp
f(10);                           // 10 是一个右值
```

`param` 被用字面值 `10` 初始化，因为你不能对 `10` 取地址，它是一个右值。这意味着在这次调用中，万能引用 `param` 被一个右值初始化，因此 `param` 成为一个右值引用，具体来说是 `int&&`。

另一方面，如果像下面这样调用 `f`：

```cpp
int x = 10;
f(x);                            // x 是一个左值
```

`param` 被变量 `x` 初始化，因为你可以对 `x` 取地址，它是一个左值。这意味着在这次调用中，万能引用 `param` 被一个左值初始化，因此 `param` 成为了一个左值引用——准确地说是 `int&`。

现在，函数 `f` 的注释应该清楚了：`param` 的类型是左值引用还是右值引用，取决于调用 `f` 时传递的是什么。有时 `param` 会成为左值引用，有时它会成为右值引用。`param` 的确是一个万能引用。

请记住，“&&” 只有在存在类型推导时才表示万能引用。如果没有类型推导，就不存在万能引用。在这种情况下，类型声明中的 “&&” 总是表示右值引用。因此：

```cpp
template<typename T>
void f(T&& param);               // 推导出的参数类型 ⇒ 类型推导；
                                 // && ≡ 万能引用
 
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs);        // 完全指定的参数类型 ⇒ 无类型推导；
    ...                          // && ≡ 右值引用
};
 
template<typename T1>
class Gadget {
    ...
    template<typename T2>
    Gadget(T2&& rhs);            // 推导出的参数类型 ⇒ 类型推导；
    ...                          // && ≡ 万能引用
};
 
void f(Widget&& param);          // 完全指定的参数类型 ⇒ 无类型推导；
                                 // && ≡ 右值引用
```

这些例子中没有任何令人意外的地方。在每种情况下，如果你看到 `T&&`（其中 `T` 是模板参数），就存在类型推导，因此你看到的是一个万能引用。而如果你在特定类型名后面看到 “&&”（例如 `Widget&&`），那你看到的是一个右值引用。

我曾提到过，要使引用声明被认为是**万能引用**，其形式必须是 `T&&`。这是一个重要的注意点。请再次查看本文开头的这段声明：

```cpp
template<typename T>
void f(std::vector<T>&& param);     // “&&” 表示右值引用
```

这里，我们既有类型推导，也有用 “&&” 声明的函数参数，但参数声明的形式并不是 `T&&`，而是 `std::vector<T>&&`。因此，该参数是一个普通的右值引用，而不是万能引用。**万能引用只能以 `T&&` 的形式出现！** 甚至仅仅添加一个 `const` 限定符，就足以让 “&&” 的解释失去万能引用的意义：

```cpp
template<typename T>
void f(const T&& param);               // “&&” 表示右值引用
```

现在，`T&&` 只是万能引用所需的形式，但这并不意味着你必须使用 `T` 作为模板参数的名称：

```cpp
template<typename MyTemplateParamType>
void f(MyTemplateParamType&& param);  // “&&” 表示万能引用
```

有时，你会在函数模板声明中看到 `T&&`，其中 `T` 是一个模板参数，但却没有类型推导发生。来看 `std::vector` 中的这个 `push_back` 函数：[3]

```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    void push_back(T&& x);       // 完全指定的参数类型 ⇒ 无类型推导；
    ...                          // && ≡ 右值引用
};
```

这里，`T` 是一个模板参数，而 `push_back` 接受一个 `T&&` 参数，但该参数不是万能引用！这是为什么呢？

答案可以通过观察 `push_back` 在类外的声明来揭示。假设我们忽略 `std::vector` 的 `Allocator` 参数，因为它与讨论无关，只会让代码更繁琐。基于此，这个版本的 `std::vector::push_back` 的声明如下：

```cpp
template <class T>
void vector<T>::push_back(T&& x);
```

`push_back` 无法独立存在，它必须依赖包含它的类 `std::vector<T>`。但如果我们已经有了 `std::vector<T>` 类，就已经知道了 `T` 是什么，因此无需再进行类型推导。

举个例子。如果我写：

```cpp
Widget makeWidget();             // Widget 的工厂函数
std::vector<Widget> vw;
...
Widget w;
vw.push_back(makeWidget());      // 从工厂创建 Widget，并将其添加到 vw
```

调用 `push_back` 会让编译器为类 `std::vector<Widget>` 实例化该函数。此时，`push_back` 的声明是这样的：

```cpp
void std::vector<Widget>::push_back(Widget&& x);
```

看到了吗？一旦我们知道类是 `std::vector<Widget>`，`push_back` 参数的类型就完全确定了：它是 `Widget&&`。这里不存在类型推导的角色。

将其与 `std::vector` 的 `emplace_back` 函数进行对比，它的声明是这样的：

```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    template <class... Args>
    void emplace_back(Args&&... args); // 推导的参数类型 ⇒ 类型推导；
    ...                                // && ≡ 万能引用
};
```

不要被 `emplace_back` 接受可变参数（由 `Args` 和 `args` 的省略号表示）这一事实分散注意力，因为这些参数的每种类型都必须被推导出来。函数模板参数 `Args` 独立于类模板参数 `T`，因此即使我们知道类是 `std::vector<Widget>`，也无法得知传递给 `emplace_back` 的参数类型。以下是忽略 `Allocator` 参数后的 `emplace_back` 在 `std::vector<Widget>` 中的类外声明：

```cpp
template<class... Args>
void std::vector<Widget>::emplace_back(Args&&... args);
```

显然，知道类是 `std::vector<Widget>` 并不能消除编译器对传递给 `emplace_back` 参数类型的推导需求。因此，`std::vector::emplace_back` 的参数是万能引用，而我们检查的 `std::vector::push_back` 的参数是右值引用。

### 重要的一点
需要记住的一点是：一个表达式是左值还是右值，与其类型是无关的。比如类型 `int`。`int` 类型有左值（如声明为 `int` 的变量），也有右值（如字面量 `10`）。对于用户定义的类型如 `Widget` 也是一样。一个 `Widget` 对象可以是左值（如一个 `Widget` 变量）或者右值（如一个工厂函数返回的对象）。表达式的类型无法告诉你它是左值还是右值。

由于一个表达式是左值还是右值，与其类型是独立的，因此可能出现以下情况：
- 一个左值，其类型是右值引用。
- 一个右值，其类型是右值引用。

示例：

```cpp
Widget makeWidget();                       // Widget 的工厂函数
 
Widget&& var1 = makeWidget();             // var1 是一个左值，但其类型是右值引用 (to Widget)
 
Widget var2 = static_cast<Widget&&>(var1); // 该转换表达式生成一个右值，但其类型是右值引用 (to Widget)
```

将左值（如 `var1`）转换为右值的常规方法是对它调用 `std::move`，因此 `var2` 可以这样定义：

```cpp
Widget var2 = std::move(var1);             // 等价于上面的定义
```

我最初用 `static_cast` 的代码仅是为了明确表达式的类型是右值引用 (`Widget&&`)。

具有右值引用类型的命名变量和参数是左值。（你可以对它们取地址。）再来看之前的 `Widget` 和 `Gadget` 模板：

```cpp
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs);        // rhs 的类型是右值引用，
    ...                          // 但 rhs 本身是左值
};
 
template<typename T1>
class Gadget {
    ...
    template <typename T2>
    Gadget(T2&& rhs);            // rhs 是万能引用，其类型最终可能成为
    ...                          // 一个右值引用或左值引用，但 rhs 本身是左值
};
```

在 `Widget` 的构造函数中，`rhs` 是右值引用，因此我们知道它绑定的是一个右值（即一个右值被传递给它），但 `rhs` 本身是一个左值，所以如果我们想利用它绑定的右值特性，就必须将它转换回右值。我们这样做的动机通常是将其用作移动操作的源头，因此将左值转换为右值的方法是使用 `std::move`。

类似地，`Gadget` 构造函数中的 `rhs` 是一个万能引用，因此它可能绑定到一个左值或右值，但无论它绑定的是什么，`rhs` 本身始终是左值。如果它绑定的是右值，而我们想利用其绑定的右值特性，我们必须将 `rhs` 转换回右值。如果它绑定的是左值，我们当然不会将其当作右值处理。这种关于万能引用绑定的值是左值还是右值的模糊性，是 `std::forward` 设计的动机所在：将一个万能引用左值转换为右值，但仅当它绑定的表达式是右值时。函数名 “forward” 是对这一功能的认可，因为我们进行这种转换几乎总是为了在将参数转发给其他函数时保留调用参数的左值或右值性质。

不过，`std::move` 和 `std::forward` 不是本文的重点。本文的重点是，类型声明中的 “&&” 是否声明了一个右值引用。为了避免偏离主题，我将关于 `std::move` 和 `std::forward` 的信息留给“进一步阅读”部分的参考资料。

### **细节详解**

问题的核心在于，C++11 中的某些构造会引发**引用的引用**（reference to reference）。在 C++ 中，引用的引用是被禁止的。如果源码中明确包含引用的引用，代码会无效，例如：

```cpp
Widget w1;
...
Widget& & w2 = w1;               // 错误！没有“引用的引用”这样的东西
```

然而，在编译过程中，由于类型操作的结果，有时会产生引用的引用。这种情况下，如果拒绝代码将是一个问题。我们从 C++98/C++03 的经验中已经知道了这一点。

对于作为万能引用的模板参数进行类型推导时，相同类型的左值和右值会被推导为略微不同的类型。具体来说，类型为 `T` 的左值会被推导为 `T&`（即左值引用），而类型为 `T` 的右值会被简单地推导为 `T`。（注意，虽然左值被推导为左值引用，但右值不会被推导为右值引用！）来看当一个接受万能引用的模板函数被调用时的情况：

```cpp
template<typename T>
void f(T&& param);

...

int x;

...

f(10);                           // 用右值调用 f
f(x);                            // 用左值调用 f
```

当用右值 `10` 调用 `f` 时，`T` 被推导为 `int`，实例化的 `f` 看起来是这样的：

```cpp
void f(int&& param);             // 从右值实例化的 f
```

这是没问题的。然而，当用左值 `x` 调用 `f` 时，`T` 被推导为 `int&`，而实例化的 `f` 包含一个**引用的引用**：

```cpp
void f(int& && param);           // 从左值实例化的 f
```

由于引用的引用，这段实例化的代码表面上无效，但源码（即调用 `f(x)`）是完全合理的。为了避免拒绝这种代码，C++11 在模板实例化等上下文中引入了**引用折叠**（reference collapsing）。

---

### **引用折叠规则**

由于有两种引用（左值引用和右值引用），因此有四种可能的引用组合：
1. 左值引用到左值引用（lvalue reference to lvalue reference）
2. 左值引用到右值引用（lvalue reference to rvalue reference）
3. 右值引用到左值引用（rvalue reference to lvalue reference）
4. 右值引用到右值引用（rvalue reference to rvalue reference）

**只有两个引用折叠规则**：
1. 一个右值引用到右值引用会折叠为（“合并为”）右值引用。
2. 所有其他的引用组合（即所有涉及左值引用的组合）都会折叠为左值引用。

将这些规则应用到用左值实例化的 `f` 会生成以下有效代码，这就是编译器如何处理该调用的方式：

```cpp
void f(int& param);              // 经过引用折叠后，用左值实例化的 f
```

这展示了万能引用如何通过类型推导和引用折叠机制最终变为左值引用的精确机制。事实上，万能引用实际上只是**处于引用折叠上下文中的右值引用**。

---

### **变量类型推导中的复杂性**

当推导一个自身是引用的变量类型时，情况会变得微妙。在这种情况下，类型的引用部分会被忽略。例如：

```cpp
int x;

...

int&& r1 = 10;                   // r1 的类型是 int&&

int& r2 = x;                     // r2 的类型是 int&
```

在调用模板函数 `f` 时，`r1` 和 `r2` 的类型都会被认为是 `int`。这种去除引用部分的行为独立于万能引用的类型推导规则（即左值被推导为 `T&`，右值被推导为 `T`）。因此，给出以下调用：

```cpp
f(r1);

f(r2);
```

`r1` 和 `r2` 的推导类型都是 `int&`。为什么？首先，`r1` 和 `r2` 的类型的引用部分被移除（都变成 `int`），然后由于它们是左值，因此在万能引用参数的类型推导中被视为 `int&`。

---

### **其他引用折叠上下文**

#### **模板实例化**

正如上文提到的，模板实例化是引用折叠发生的一个上下文。

#### **`auto` 变量的类型推导**

对于作为万能引用的 `auto` 变量，类型推导规则本质上与模板函数参数的类型推导相同，因此类型为 `T` 的左值会被推导为 `T&`，而类型为 `T` 的右值会被推导为 `T`。再次看一下本文开头的这个例子：

```cpp
Widget&& var1 = someWidget;      // var1 的类型是 Widget&&（这里没有使用 auto）

auto&& var2 = var1;              // var2 的类型是 Widget&（见下文）
```

`var1` 的类型是 `Widget&&`，但在初始化 `var2` 时，其引用性会被忽略，它被视为 `Widget` 类型。由于它是一个左值，被用于初始化万能引用（`var2`），其推导类型为 `Widget&`。将 `Widget&` 替代 `auto` 放入 `var2` 的定义中会生成以下无效代码：

```cpp
Widget& && var2 = var1;          // 注意引用的引用
```

经过引用折叠后，这变为：

```cpp
Widget& var2 = var1;             // var2 的类型是 Widget&
```

#### **typedef 的形成与使用**

这是引用折叠发生的另一个上下文。考虑以下类模板：

```cpp
template<typename T>
class Widget {
    typedef T& LvalueRefType;
    ...
};
```

以及以下模板的使用：

```cpp
Widget<int&> w;
```

实例化后的类会包含以下（无效的）typedef：

```cpp
typedef int& & LvalueRefType;
```

引用折叠将其简化为合法代码：

```cpp
typedef int& LvalueRefType;
```

如果我们在某个上下文中使用这个 typedef，例如：

```cpp
void f(Widget<int&>::LvalueRefType&& param);
```

展开 typedef 后会产生以下无效代码：

```cpp
void f(int& && param);
```

但引用折叠生效，因此最终的函数声明是：

```cpp
void f(int& param);
```

#### **`decltype` 表达式**

`decltype` 是引用折叠发生的另一个上下文。与模板和 `auto` 不同，`decltype` 对表达式进行类型推导时采用不同的规则。这些规则过于复杂，无法在本文详述（可以参考“进一步阅读”部分的相关资料）。值得注意的区别是：`decltype` 给定一个非引用类型的命名变量时，推导的类型是 `T`（即非引用类型），而在相同条件下，模板和 `auto` 会推导为 `T&`。

---

### **总结**

在类型声明中，“&&” 表示**右值引用**或**万能引用**（一种可能解析为左值引用或右值引用的引用）。万能引用的形式总是 `T&&`，其中 `T` 是某种推导出的类型。

**引用折叠**是使万能引用（实际上是右值引用）在某些上下文中解析为左值引用或右值引用的机制。它发生在编译期间可能产生引用的引用的特定上下文中。这些上下文包括模板类型推导、`auto` 类型推导、`typedef` 的形成与使用以及 `decltype` 表达式。